from nptyping import Double, NDArray, Shape
from scipy import sparse
from scipy.integrate import solve_ivp
from typing import Callable, Generator, Iterable, TypeVar, Tuple
# import numba as nb
import numpy as np


Ts = NDArray[Shape['*'], Double]
X = NDArray[Shape['*'], Double]
Xs = NDArray[Shape['*, N'], Double]
M = NDArray[Shape['N, N'], Double]
R2 = NDArray[Shape['2'], Double]
R2s = NDArray[Shape['*, 2'], Double]
T2s = NDArray[Shape['*, 2'], Double]
S1s = TypeVar('S1s', float, NDArray[Shape['*'], Double])


def flow(v: Callable[[X], X], t: float) -> Callable[[X], X]:
    """Time-t flow generated by vector field.

    This function is a wrapper of the solve_ivp initial-value problem solver
    from scipy.integrate.

    :v: Vector field.
    :t: Integration time.
    :returns: Time-t flow map.

    """
    def vt(t: float, x: X) -> X:
        y = v(x)
        return y

    def phi(x: X) -> X:
        out = solve_ivp(vt, [0, t], x, t_eval=[t], atol=1e-8, rtol=1e-8)
        y: X = out.y[:, 0]
        return y
    return phi


def flows(v: Callable[[X], X], ts: Ts) -> Callable[[X], Xs]:
    """Flow generated by vector field evaluated at multiple time points.

    This function is a wrapper of the solve_ivp initial-value problem solver
    from scipy.integrate.

    :v: Vector field.
    :t: Integration time.
    :returns: Time-t flow map.

    """
    def vt(t: float, x: X) -> X:
        y = v(x)
        return y

    def phi(x: X) -> Xs:
        out = solve_ivp(vt, [0, ts[-1]], x, t_eval=ts, atol=1e-8, rtol=1e-8)
        y: Xs = out.y.T
        return y
    return phi


def circle_rotation(a: float) -> Callable[[S1s], S1s]:
    """Circle rotation."""
    def phi(x: S1s) -> S1s:
        y = (x + a) % (2 * np.pi)
        return y
    return phi


def torus_rotation(a: Tuple[float, float]) -> Callable[[T2s], T2s]:
    """Torus rotation."""
    def phi(x: T2s) -> T2s:
        y = (x + a) % (2 * np.pi)
        return y
    return phi


def circle_embedding_r2(x: S1s) -> R2s:
    """Standard embedding of the circle into R2."""
    y = np.empty((*x.shape, 2))
    y[..., 0] = np.cos(x)
    y[..., 1] = np.sin(x)
    return y


# TODO: Consider flattening the signature of stepanoff_vec to (float, R2) -> R2
# and using numba jit for improved efficiency. The current high-order
# implementation does not work with numba.
def stepanoff_vec(alpha: float) -> Callable[[R2], R2]:
    """Vector field of the Stepanoff flow on the 2-torus.

    :alpha: Frequency parameter.
    :returns: Stepanoff vector field.

    """
    # @nb.jit
    def v(x: R2) -> R2:
        y = np.empty(2)
        y[1] = alpha * (1 - np.cos(x[0] - x[1]))
        y[0] = y[1] + (1 - alpha) * (1 - np.cos(x[1]))
        return y
    return v


def stepanoff_generator(alpha: float, k: int) -> M:
    """Matrix representation of the generator of a Stepanoff flow on the
    2-torus with respect to the Fourier basis.

    alpha: Frequency parameter.
    k: Spectral resolution parameter (max. Fourier wavenumber).

    return: n^2 by n^2 generator matrix v with n = 2 * k + 1.

    In the implementation, the matrices v1 and v2 represent differentiation
    along the first and second dimension of the 2-torus, respectively.
    """

    n = 2 * k + 1

    # The following code block builds n by n matrices. m1 and mk have nonzero
    # entries in the main diagonal, l1 and lk have nonzero entries in the first
    # lower diagonal,and u1 and uk have nonzero entries in the first upper
    # diagonal.
    m1 = sparse.eye(n, format="dia")
    mk = sparse.diags(np.arange(-k, k + 1), 0, format="dia")
    l1 = sparse.diags(np.ones(n - 1), -1, format="dia")
    lk = sparse.diags(np.arange(-k, k), -1, format="dia")
    u1 = sparse.diags(np.ones(n - 1), 1, format="dia")
    uk = sparse.diags(np.arange(-k + 1, k + 1), 1, format="dia")

    # We now build n^2 by n^2 matrices as Kronecker products of the n by n
    # matrices introduced above.
    m1_mk = sparse.kron(m1, mk)
    mk_m1 = sparse.kron(mk, m1)
    l1_mk = sparse.kron(l1, mk)
    l1_uk = sparse.kron(l1, uk)
    lk_u1 = sparse.kron(lk, u1)
    u1_mk = sparse.kron(u1, mk)
    u1_lk = sparse.kron(u1, lk)
    uk_l1 = sparse.kron(uk, l1)

    # Finally, we assemble the generator matrix.
    v2 = alpha * (mk_m1 - (uk_l1 + lk_u1) / 2)
    v1 = m1_mk - (alpha * (u1_lk + l1_uk) + (1 - alpha) * (l1_mk + u1_mk)) / 2
    v: M = 1j * (v1 + v2)

    return v
