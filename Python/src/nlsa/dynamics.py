"""Provides generic functions for dynamical systems computations.

"""
import nlsa.abstract_algebra2 as alg
from functools import partial
from nlsa.abstract_algebra2 import identity, FromScalarField
from nlsa.function_algebra2 import BivariateFunctionSpace, compose
from nlsa.kernels import make_integral_operator
from nlsa.utils import swap_args
from typing import Callable, Generator, Iterable, TypeVar

T = TypeVar('T')
S = TypeVar('S')
F = Callable[[S], T]
V = TypeVar('V')
X = TypeVar('X')
TX = TypeVar('TX')
Y = TypeVar('Y')
K = TypeVar('K')


def semigroup(f: Callable[[X], X]) -> Generator[Callable[[X], X], None, None]:
    """Semigroup generated by map."""
    g = identity
    while True:
        yield g
        g = compose(f, g)


def orbit(x0: X, f: Callable[[X], X]) -> Generator[X, None, None]:
    """Orbit of a point under iterated application of a map."""
    x = x0
    while True:
        yield x
        x = f(x)


def cocycle_orbit(y0: Y, xs: Iterable[X], f: Callable[[X, Y], Y])\
        -> Generator[Y, None, None]:
    """Orbit of a point under a cocycle.

    :y0: Initial condition.
    :xs: Base space trajectory.
    :returns: Generator of cocycle trajectory.

    """
    y = y0
    for x in xs:
        yield y
        y = f(x, y)


def make_resolvent_from_generator(impl: alg.ImplementsMeasureFnAlgebra[X, V, K],
                                  v: Callable[[X], TX], z: K,
                                  k: Callable[[X, X], K],
                                  jvp: Callable[[F[X, K], X, TX], F[X, K]],
                                  lsolve: Callable[[F[V, V], V], V]) \
      -> Callable[[V], F[X, K]]:
    """Make resolvent operator using Jacobian vector product."""

    fun: BivariateFunctionSpace[X, X, K, K] = \
        BivariateFunctionSpace(codomain=FromScalarField(impl.scl))

    @swap_args
    def v_grad_k(x: X, y: X) -> K:
        _, vgp = jvp(partial(swap_args(k), x), (y,), (v(y),))
        return vgp

    zk_minus_v_grad_k = fun.sub(fun.smul(z, k), v_grad_k)
    inv_res_k_op: Callable[[V], F[X, K]] = \
        make_integral_operator(impl, zk_minus_v_grad_k)
    inv_res_g_op: Callable[[V], V] = compose(impl.incl, inv_res_k_op)
    k_op: Callable[[V], F[X, K]] = make_integral_operator(impl, k)

    def res(u: V) -> F[X, K]:
        w, _ = lsolve(inv_res_g_op, u)
        return k_op(w)

    return res
