import jax.numpy as jnp
from diffrax import Dopri5, ODETerm, PIDController, diffeqsolve
from jax import Array
from typing import Callable, Optional

R2 = Array
T2 = Array
X = Array
V = Array
M = Array
I2 = tuple[int, int]


def flow(v: Callable[[X], X], t: float, /, dt0: Optional[float] = None)\
        -> Callable[[X], X]:
    """Compute time-t flow generated by vector field."""
    def f(t: float, x: X, args: object) -> X:
        y = v(x)
        return y

    term = ODETerm(f)
    solver = Dopri5()
    stepsize_controller = PIDController(rtol=1e-8, atol=1e-8)
    if dt0 is None:
        dt0 = t / 10

    def phi(x: X) -> X:
        solution = diffeqsolve(term, solver, t0=0, t1=t, dt0=dt0, y0=x,
                               stepsize_controller=stepsize_controller)
        y: X = solution.ys[0]
        return y
    return phi


def make_stepanoff_vector_field(alpha: float) -> Callable[[R2], R2]:
    """Make vector field of the Stepanoff flow on the 2-torus."""

    def vec(x: T2) -> R2:
        y = jnp.empty(2)
        y = y.at[1].set(alpha * (1 - jnp.cos(x[0] - x[1])))
        y = y.at[0].set(y[1] + (1 - alpha) * (1 - jnp.cos(x[1])))
        return y
    return vec


def make_stepanoff_generator_fourier(alpha: float, k: I2,
                                     hermitian: bool = False) \
        -> Callable[[V], V]:
    """Make generator of Stepanoff flow in the Fourier basis of the 2-torus."""
    n1 = 2*k[0] + 1
    n2 = 2*k[1] + 1
    k1 = jnp.arange(-k[0], k[0] + 1)
    k2 = jnp.arange(-k[1], k[1] + 1)

    if hermitian:
        const = 1.
        b0 = jnp.zeros((n1, n2, 8), dtype=jnp.float32)
    else:
        const = 1j
        b0 = jnp.zeros((n1, n2, 8), dtype=jnp.complex64)

    def gen(u: V) -> V:
        a = jnp.reshape(u, (n1, n2))
        b = b0

        # Terms associated with derivative along coordinate 1
        b = b.at[:, :, 0].set(const * k1[:, jnp.newaxis] * a)
        b = b.at[1:, :-1, 1].set(
                -const * 0.5 * alpha * k1[:-1, jnp.newaxis] * a[:-1, 1:])
        b = b.at[:-1, 1:, 2].set(
                -const * 0.5 * alpha * k1[1:, jnp.newaxis] * a[1:, :-1])
        b = b.at[:, 1:, 3].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, :-1])
        b = b.at[:, :-1, 4].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, 1:])

        # Terms associated with derivative along coordinate 2
        b = b.at[:, :, 5].set(const * alpha * k2 * a)
        b = b.at[1:, :-1, 6].set(-const * 0.5 * alpha * k2[1:] * a[:-1, 1:])
        b = b.at[:-1, 1:, 7].set(-const * 0.5 * alpha * k2[:-1] * a[1:, :-1])

        c = jnp.sum(b, axis=2)
        return jnp.reshape(c, n1 * n2)

    return gen


def stepanoff_generator_matrix(alpha: float, k: int, hermitian: bool = False) \
        -> M:
    """Compute matrix representation of Stepanoff generator Fourier basis.

    In this implementation, the matrices v1 and v2 represent differentiation
    along the first and second dimension of the 2-torus, respectively.
    """

    n = 2*k + 1

    if hermitian:
        const = 1.
    else:
        const = 1j

    # The following code block builds n by n matrices. m1 and mk have nonzero
    # entries in the main diagonal, l1 and lk have nonzero entries in the first
    # lower diagonal,and u1 and uk have nonzero entries in the first upper
    # diagonal.
    m1 = jnp.eye(n)
    mk = jnp.diag(jnp.arange(-k, k + 1), 0)
    l1 = jnp.diag(jnp.ones(n - 1), -1)
    lk = jnp.diag(jnp.arange(-k, k), -1)
    u1 = jnp.diag(jnp.ones(n - 1), 1)
    uk = jnp.diag(jnp.arange(-k + 1, k + 1), 1)

    # We now build n^2 by n^2 matrices as Kronecker products of the n by n
    # matrices introduced above.
    m1_mk = jnp.kron(m1, mk)
    mk_m1 = jnp.kron(mk, m1)
    l1_mk = jnp.kron(l1, mk)
    l1_uk = jnp.kron(l1, uk)
    lk_u1 = jnp.kron(lk, u1)
    u1_mk = jnp.kron(u1, mk)
    u1_lk = jnp.kron(u1, lk)
    uk_l1 = jnp.kron(uk, l1)

    # Finally, we assemble the generator matrix.
    v2 = alpha * (mk_m1 - (uk_l1 + lk_u1) / 2)
    v1 = m1_mk - (alpha * (u1_lk + l1_uk) + (1 - alpha) * (l1_mk + u1_mk)) / 2
    v: M = const * (v1 + v2)

    return v
