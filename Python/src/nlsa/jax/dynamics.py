import jax.numpy as jnp
from diffrax import Dopri5, ODETerm, PIDController, diffeqsolve
from jax import Array
from jax.numpy.fft import ifft, fft
from typing import Callable, Optional

R2 = Array
R3 = Array
Rn = Array
T2 = Array
Tn = Array
X = Array
V = Array
Vpos = Array
M = Array
I2 = tuple[int, int]

twopi = 2.0 * jnp.pi


def from_autonomous(v: Callable[[X], X]) -> Callable[[float, X, object], X]:
    """Make time-dependent vector field from autonomous vector field."""
    def f(t: float, x: X, args: object) -> X:
        y = v(x)
        return y
    return f


def flow(v: Callable[[X], X], t: float, /, dt0: Optional[float] = None)\
        -> Callable[[X], X]:
    """Compute time-t flow generated by vector field."""
    def f(t: float, x: X, args: object) -> X:
        y = v(x)
        return y

    term = ODETerm(f)
    solver = Dopri5()
    stepsize_controller = PIDController(rtol=1e-8, atol=1e-8)
    if dt0 is None:
        dt0 = t / 10

    def phi(x: X) -> X:
        solution = diffeqsolve(term, solver, t0=0, t1=t, dt0=dt0, y0=x,
                               stepsize_controller=stepsize_controller)
        y: X = solution.ys[0]
        return y
    return phi


def make_posfreq_to_l2(k_max: int) -> Callable[[Vpos], V]:
    """Make embedding of positive-frequency subspace into L2."""
    def iota(vpos: Vpos) -> V:
        w = jnp.empty(2*k_max + 1)
        w = w.at[0:k_max + 1].set(ifft(vpos))
        w = w.at[k_max:] = 0.0
        return w
    return iota


def make_l2_to_posfreq(k_max: int) -> Callable[[V], Vpos]:
    """Make projection from L2 into positive-frequency subspace."""
    def prj(v: V) -> Vpos:
        v_hat = fft(v)
        return v_hat[0:k_max + 1]
    return prj


def make_l63_vector_field(rho: float = 28., sigma: float = 10.,
                          beta: float = 8. / 3.)\
      -> Callable[[R3], R3]:
    """Make vector field of the Lorenz 63 system."""
    def vec(x: R3) -> R3:
        y = jnp.empty(3)
        y = y.at[0].set(sigma*(x[1] - x[0]))
        y = y.at[1].set(x[0]*(rho - x[2]) - x[1])
        y = y.at[2].set(x[0]*x[1] - beta*x[2])
        return y
    return vec


def make_stepanoff_vector_field(alpha: float, dtype=jnp.float32) \
        -> Callable[[T2], R2]:
    """Make vector field of the Stepanoff flow on the 2-torus."""
    def vec(x: T2) -> R2:
        y = jnp.empty(2)
        y = y.at[1].set(alpha * (1. - jnp.cos(x[0] - x[1])))
        y = y.at[0].set(y[1] + (1. - alpha) * (1. - jnp.cos(x[1])))
        return y
    return vec


def make_rotation_vector_field(alphas: Rn) -> Callable[[Tn], Rn]:
    """Make vector field generating linear rotation on the n-torus."""
    def vec(_: Tn) -> Rn:
        return alphas
    return vec


def make_rotation_map(angles: Tn, mod: float = twopi) -> Callable[[Tn], Tn]:
    """Make linear rotation map on the n-torus."""
    def phi(theta: Tn) -> Tn:
        return (theta + angles) % mod
    return phi


def make_rotation_generator_fourier(alphas: tuple[float], k: I2,
                                    hermitian: bool = False,
                                    dtype=jnp.float32) \
        -> Callable[[V], V]:
    """Make rotation generator in the Fourier basis of the 2-torus."""
    n1 = 2*k[0] + 1
    n2 = 2*k[1] + 1
    k1 = jnp.arange(-k[0], k[0] + 1, dtype=dtype)
    k2 = jnp.arange(-k[1], k[1] + 1, dtype=dtype)

    if hermitian:
        const = dtype(1.)
    else:
        const = 1j

    def gen(u: V) -> V:
        a = jnp.reshape(u, (n1, n2))
        b = (k1[:, jnp.newaxis]*alphas[0] + k2[jnp.newaxis, :]*alphas[1]) * a
        return const * b.reshape(n1 * n2)

    return gen


def make_stepanoff_generator_fourier(alpha: float, k: I2,
                                     hermitian: bool = False,
                                     dtype=jnp.float32) \
        -> Callable[[V], V]:
    """Make generator of Stepanoff flow in the Fourier basis of the 2-torus."""
    n1 = 2*k[0] + 1
    n2 = 2*k[1] + 1
    k1 = jnp.arange(-k[0], k[0] + 1, dtype=dtype)
    k2 = jnp.arange(-k[1], k[1] + 1, dtype=dtype)

    if hermitian:
        const = dtype(1.0)
        b0 = jnp.zeros((n1, n2, 8), dtype=dtype)
    else:
        const = 1j
        b0 = jnp.zeros((n1, n2, 8), dtype=jnp.complex64)

    def gen(u: V) -> V:
        a = jnp.reshape(u, (n1, n2))
        b = b0

        # Terms associated with derivative along coordinate 1
        b = b.at[:, :, 0].set(const * k1[:, jnp.newaxis] * a)
        b = b.at[1:, :-1, 1].set(
                -const * 0.5 * alpha * k1[:-1, jnp.newaxis] * a[:-1, 1:])
        b = b.at[:-1, 1:, 2].set(
                -const * 0.5 * alpha * k1[1:, jnp.newaxis] * a[1:, :-1])
        b = b.at[:, 1:, 3].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, :-1])
        b = b.at[:, :-1, 4].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, 1:])

        # Terms associated with derivative along coordinate 2
        b = b.at[:, :, 5].set(const * alpha * k2 * a)
        b = b.at[1:, :-1, 6].set(-const * 0.5 * alpha * k2[1:] * a[:-1, 1:])
        b = b.at[:-1, 1:, 7].set(-const * 0.5 * alpha * k2[:-1] * a[1:, :-1])

        c = jnp.sum(b, axis=2)
        return jnp.reshape(c, n1 * n2)

    return gen


def stepanoff_generator_matrix(alpha: float, k: int, hermitian: bool = False) \
        -> M:
    """Compute matrix representation of Stepanoff generator Fourier basis.

    In this implementation, the matrices v1 and v2 represent differentiation
    along the first and second dimension of the 2-torus, respectively.
    """

    n = 2*k + 1

    if hermitian:
        const = 1.
    else:
        const = 1j

    # The following code block builds n by n matrices. m1 and mk have nonzero
    # entries in the main diagonal, l1 and lk have nonzero entries in the first
    # lower diagonal,and u1 and uk have nonzero entries in the first upper
    # diagonal.
    m1 = jnp.eye(n)
    mk = jnp.diag(jnp.arange(-k, k + 1), 0)
    l1 = jnp.diag(jnp.ones(n - 1), -1)
    lk = jnp.diag(jnp.arange(-k, k), -1)
    u1 = jnp.diag(jnp.ones(n - 1), 1)
    uk = jnp.diag(jnp.arange(-k + 1, k + 1), 1)

    # We now build n^2 by n^2 matrices as Kronecker products of the n by n
    # matrices introduced above.
    m1_mk = jnp.kron(m1, mk)
    mk_m1 = jnp.kron(mk, m1)
    l1_mk = jnp.kron(l1, mk)
    l1_uk = jnp.kron(l1, uk)
    lk_u1 = jnp.kron(lk, u1)
    u1_mk = jnp.kron(u1, mk)
    u1_lk = jnp.kron(u1, lk)
    uk_l1 = jnp.kron(uk, l1)

    # Finally, we assemble the generator matrix.
    v2 = alpha * (mk_m1 - (uk_l1 + lk_u1) / 2)
    v1 = m1_mk - (alpha * (u1_lk + l1_uk) + (1 - alpha) * (l1_mk + u1_mk)) / 2
    v: M = const * (v1 + v2)

    return v
