# pyright: basic

"""Provide functions for dynamical systems computations implemented in JAX."""
import jax.numpy as jnp
import jax
from collections.abc import Callable
from diffrax import Dopri5, ODETerm, PIDController, diffeqsolve
from jax import Array, jvp
from jax.numpy.fft import ifft, fft
from jax.typing import ArrayLike, DTypeLike
from jaxtyping import Real
from typing import Sequence, Optional, cast

type R = Array
type R2 = Array
type R3 = Array
type Rn = Array
type T2 = Array
type Tn = Array
type X = Array
type Xs = Array
type V = Array
type Vpos = Array
type M = Array


def make_fin_orbit(f: Callable[[X], X], num_steps: int = 1) \
        -> Callable[[X], Xs]:
    """Make function implementing orbit under finite applications of a map."""
    def body_fun(i: int, xs: Xs) -> Xs:
        return xs.at[i].set(f(xs[i - 1]))

    def orb(x: X) -> Xs:
        xs = jnp.empty((num_steps,) + x.shape, dtype=x.dtype)
        xs = xs.at[0].set(x)
        return jax.lax.fori_loop(1, num_steps, body_fun, xs)
    return orb


def vgrad[X: Array, TX: Array](g: Callable[[X], R]) \
        -> Callable[[X, TX], R]:
    """Make directional derivative with respect to vector field."""
    def h(x: X, v: TX) -> R:
        _, hx = jvp(g, (x,), (v,))
        return hx
    return h


def flow(v: Callable[[X], X], t: Real, /, dt0: Optional[Real] = None) \
        -> Callable[[X], X]:
    """Compute time-t flow generated by vector field."""
    def f(t: Real, x: X, args: Array) -> X:
        y = v(x)
        return y

    term = ODETerm(f)
    solver = Dopri5()
    stepsize_controller = PIDController(rtol=1e-8, atol=1e-8)
    if dt0 is None:
        dt0 = t / 10.0

    def phi(x: X) -> X:
        solution = diffeqsolve(term, solver, t0=0.0, t1=t, dt0=dt0, y0=x,
                               stepsize_controller=stepsize_controller)
        y = cast(X, solution.ys)[0]
        # y = solution.ys[0]
        return y
    return phi


def make_posfreq_to_l2(k_max: int, dtype: Optional[DTypeLike] = None) \
        -> Callable[[Vpos], V]:
    """Make embedding of positive-frequency subspace into L2."""
    def iota(vpos: Vpos) -> V:
        w = jnp.empty(2*k_max + 1, dtype=dtype)
        w = w.at[0:k_max + 1].set(ifft(vpos))
        w = w.at[k_max:].set(0)
        return w
    return iota


def make_l2_to_posfreq(k_max: int) -> Callable[[V], Vpos]:
    """Make projection from L2 into positive-frequency subspace."""
    def prj(v: V) -> Vpos:
        v_hat = fft(v)
        return v_hat[0:k_max + 1]
    return prj


def make_l63_vector_field(rho: float = 28.0, sigma: float = 10.0,
                          beta: float = 8.0 / 3.0,
                          dtype: Optional[DTypeLike] = None) \
      -> Callable[[R3], R3]:
    """Make vector field of the Lorenz 63 system."""
    def vec(x: R3) -> R3:
        y = jnp.empty(3, dtype=dtype)
        y = y.at[0].set(sigma*(x[1] - x[0]))
        y = y.at[1].set(x[0]*(rho - x[2]) - x[1])
        y = y.at[2].set(x[0]*x[1] - beta*x[2])
        return y
    return vec


def make_stepanoff_vector_field(alpha: float,
                                dtype: Optional[DTypeLike] = None) \
        -> Callable[[T2], R2]:
    """Make vector field of the Stepanoff flow on the 2-torus."""
    def vec(x: T2) -> R2:
        y = jnp.empty(2, dtype=dtype)
        y = y.at[1].set(alpha * (1 - jnp.cos(x[0] - x[1])))
        y = y.at[0].set(y[1] + (1 - alpha) * (1 - jnp.cos(x[1])))
        return y
    return vec


def make_rotation_vector_field[D: DTypeLike](
        freqs: float | Sequence[float] | ArrayLike,
        dtype: Optional[D] = None) -> Callable[[Tn], Rn]:
    """Make vector field generating linear rotation on the n-torus."""
    freqs_arr = jnp.array(freqs, dtype=dtype)

    def vec(_: Tn, /) -> Rn:
        return freqs_arr
    return vec


def make_rotation_map[D: DTypeLike](
        angles: float | Sequence[float] | ArrayLike, mod: float = 2*jnp.pi,
        dtype: Optional[D] = None) -> Callable[[Tn], Tn]:
    """Make linear rotation map on the n-torus."""
    angles_arr = jnp.array(angles, dtype=dtype)

    def phi(theta: Tn, /) -> Tn:
        return (theta + angles_arr) % mod
    return phi


def make_t2_rotation_generator_fourier(alphas: tuple[float, float],
                                       k: tuple[int, int],
                                       hermitian: bool = False,
                                       dtype: Optional[DTypeLike] = None) \
        -> Callable[[V], V]:
    """Make rotation generator in the Fourier basis of the 2-torus."""
    n1 = 2*k[0] + 1
    n2 = 2*k[1] + 1
    k1 = jnp.arange(-k[0], k[0] + 1, dtype=dtype)
    k2 = jnp.arange(-k[1], k[1] + 1, dtype=dtype)
    if hermitian:
        const = jnp.array(1.0, dtype=dtype)
    else:
        const = jnp.array(1j, dtype=dtype)

    def gen(u: V) -> V:
        a = jnp.reshape(u, (n1, n2))
        b = (k1[:, jnp.newaxis]*alphas[0] + k2[jnp.newaxis, :]*alphas[1]) * a
        return const * b.reshape(n1 * n2)
    return gen


def make_stepanoff_generator_fourier(alpha: float, k: tuple[int, int],
                                     hermitian: bool = False,
                                     dtype: Optional[DTypeLike] = None) \
        -> Callable[[V], V]:
    """Make generator of Stepanoff flow in the Fourier basis of the 2-torus."""
    n1 = 2*k[0] + 1
    n2 = 2*k[1] + 1
    k1 = jnp.arange(-k[0], k[0] + 1, dtype=dtype)
    k2 = jnp.arange(-k[1], k[1] + 1, dtype=dtype)
    if hermitian:
        const = jnp.array(1.0, dtype=dtype)
        b0 = jnp.zeros((n1, n2, 8), dtype=dtype)
    else:
        const = jnp.array(1j, dtype=dtype)
        b0 = jnp.zeros((n1, n2, 8), dtype=dtype)

    def gen(u: V) -> V:
        a = jnp.reshape(u, (n1, n2))
        b = b0

        # Terms associated with derivative along coordinate 1
        b = b.at[:, :, 0].set(const * k1[:, jnp.newaxis] * a)
        b = b.at[1:, :-1, 1].set(
                -const * 0.5 * alpha * k1[:-1, jnp.newaxis] * a[:-1, 1:])
        b = b.at[:-1, 1:, 2].set(
                -const * 0.5 * alpha * k1[1:, jnp.newaxis] * a[1:, :-1])
        b = b.at[:, 1:, 3].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, :-1])
        b = b.at[:, :-1, 4].set(
                -const * 0.5 * (1.0 - alpha) * k1[:, jnp.newaxis] * a[:, 1:])

        # Terms associated with derivative along coordinate 2
        b = b.at[:, :, 5].set(const * alpha * k2 * a)
        b = b.at[1:, :-1, 6].set(-const * 0.5 * alpha * k2[1:] * a[:-1, 1:])
        b = b.at[:-1, 1:, 7].set(-const * 0.5 * alpha * k2[:-1] * a[1:, :-1])

        c = jnp.sum(b, axis=2)
        return jnp.reshape(c, n1 * n2)
    return gen


def stepanoff_generator_matrix(alpha: float, k: int, hermitian: bool = False,
                               dtype: Optional[DTypeLike] = None) \
        -> M:
    """Compute matrix representation of Stepanoff generator Fourier basis.

    In this implementation, the matrices v1 and v2 represent differentiation
    along the first and second dimension of the 2-torus, respectively.
    """
    n = 2*k + 1
    if hermitian:
        const = jnp.array(1.0, dtype=dtype)
    else:
        const = jnp.array(1j, dtype=dtype)

    # The following code block builds n by n matrices. m1 and mk have nonzero
    # entries in the main diagonal, l1 and lk have nonzero entries in the first
    # lower diagonal,and u1 and uk have nonzero entries in the first upper
    # diagonal.
    m1 = jnp.eye(n, dtype=dtype)
    mk = jnp.diag(jnp.arange(-k, k + 1, dtype=dtype), 0)
    l1 = jnp.diag(jnp.ones(n - 1, dtype=dtype), -1)
    lk = jnp.diag(jnp.arange(-k, k, dtype=dtype), -1)
    u1 = jnp.diag(jnp.ones(n - 1, dtype=dtype), 1)
    uk = jnp.diag(jnp.arange(-k + 1, k + 1, dtype=dtype), 1)

    # We now build n^2 by n^2 matrices as Kronecker products of the n by n
    # matrices introduced above.
    m1_mk = jnp.kron(m1, mk)
    mk_m1 = jnp.kron(mk, m1)
    l1_mk = jnp.kron(l1, mk)
    l1_uk = jnp.kron(l1, uk)
    lk_u1 = jnp.kron(lk, u1)
    u1_mk = jnp.kron(u1, mk)
    u1_lk = jnp.kron(u1, lk)
    uk_l1 = jnp.kron(uk, l1)

    # Finally, we assemble the generator matrix.
    v2 = alpha * (mk_m1 - (uk_l1 + lk_u1) / 2)
    v1 = m1_mk - (alpha * (u1_lk + l1_uk) + (1 - alpha) * (l1_mk + u1_mk)) / 2
    v = const * (v1 + v2)
    return v
