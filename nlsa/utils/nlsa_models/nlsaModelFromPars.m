function model = nlsaModelFromPars( Data, Pars )
% NLSAMODELFROMPARS Create NLSA model from data sources and parameters.
%
%  This function creates typical nlsaModel configurations based on in-sample,
%  and optionally, out-sample data and parameters. 
%
%  model = nlsaModelFromPars( Data, Pars ) creates typical NLSA model
%  configurations base on data passed in a structure Data and parameters in a 
%  structure Pars.
%
%  Data has the following fields:
%
%  Data.src:    % in-sample source components
%  Data.trg:    % in-sample target components
%  Data.out:    % out-of-sample source components (optional)
%  Data.outTrg: % out-of-sample target components (optional)
%
%  Pars has the following fields:
% 
%  Pars.In:  % structure containing in-sample model parameters
%  Pars.Out: % structure containing out-of-sample model parameters (optional)
%
%  nlsaModelFromPars converts the parameters in Pars to appropriate arguments 
%  for the nlsaModel class constructors, and then calls the constructors to 
%  build the model.
%
%  nlsaModelFromPars is meant to be called by higher-level functions 
%  tailored to specific datasets. 
%
%  For additional information on the class constructors see 
%
%      /nlsa/classes/nlsaModel_base/nlsaModel_base.m
%      /nlsa/classes/nlsaModel/nlsaModel.m
%      /nlsa/classes/nlsaModel_den/nlsaModel_den.m
%      /nlsa/classes/nlsaModel_den_ose/nlsaModel_den_ose.m
%
%
% Modified 2023/07/31
 
%% PRELIMINARY CHECKS
% Check that in-sample parameters are present
if isfield( Pars, 'In' )
    In = Pars.In;
else
    error( 'Missing in-sample parameters.' )
end

% Check if we are using separate query/test partitions
if isfield( In, 'nBQ' ) && In.nBQ > 0
    ifPartitionQ = true;
else
    ifPartitionQ = false;
end
if isfield( In, 'nBT' ) && In.nBT > 0
    ifPartitionT = true;
else
    ifPartitionT = false;
end

% Check if we are doing out-of-sample extension
if isfield( Pars, 'Out' )
    ifOse = true;
    Out = Pars.Out;
else
    ifOse = false; 
end

% Check if we are using kernel density estimation
if isfield( In, 'denType' )
    ifDen = true;
else
    ifDen = false;
end

% Check if the model has Koopman operators
if isfield( In, 'koopmanOpType' )
    ifKoopman = true;
else
    ifKoopman = false;
end

% Check that required high-level fields are present
if ~isfield( In, 'Src' )
    error( 'Source field Src missing from in-sample parameters.' )
end
if ~isfield( In, 'Res' )
    error( 'Realization field Res missing from in-sample parameters.' )
end
if ifOse && ~isfield( Out, 'Res' )
    error( 'Realization field Res missing from out-of-sample parameters.' )
end

%% ROOT DIRECTORY NAMES
% NLSA output
if isfield( In, 'nlsaPath' )
    nlsaPath = In.nlsaPath;
else
    nlsaPath = fullfile( pwd, 'data/nlsa' ); % nlsa output
    In.nlsaPath = nlsaPath;
end

%% ASSEMBLE DATA SOURCES
srcComponent = Data.src; 
trgComponent = Data.trg;
if ifOse
    outComponent = Data.out;
end
if ifOse && isfield( Data, 'outTrg' )
    outTargetComponentArg = { 'outTargetComponent', Data.outTrg };
    ifOutTrg = true;
else
    outTargetComponentArg = {};
    ifOutTrg = false;
end
In.nC  = size( Data.src, 1 );
In.nR  = size( Data.src, 2 ); 
In.nCT = size( Data.trg, 1 );
if ~isfield( In, 'Src' ) || numel( In.Src ) ~= In.nC 
    error( 'Incompatible source components and parameter array.' )
end 
if ~isfield( In, 'Res' ) || numel( In.Res ) ~= In.nR
    error( 'Incompatible source realizations and parameter array.' )
end
if ~isfield( In, 'Trg' ) || numel( In.Trg ) ~= In.nCT
    error( 'Incompatible target components and parameter array.' )
end
if ifDen
    if In.nC > 1 && isscalar(In.denND)
        In.denND = repmat(In.denND, [In.nC 1]);
    elseif In.nC > 1 && numel(In.denND) ~= In.nC
        error('Incompatible source components and dimension array for KDE.')
    end
end
if ifDen && ifOse
    if Out.nC > 1 && isscalar(Out.denND)
        Out.denND = repmat(Out.denND, [Out.nC 1]);
    elseif Out.nC > 1 && numel(Out.denND) ~= Out.nC
        error('Incompatible OS source components and dimension array for KDE.')
    end
end
if ifOse 
    Out.nC = size( Data.out, 1 );
    Out.nR = size( Data.out, 2 );
    if ~isfield( Out, 'Src' ) || numel( Out.Src ) ~= Out.nC
        error( 'Incompatible OS source components and parameter array.' )
    end
    if ~isfield( Out, 'Res' ) || numel( Out.Res ) ~= Out.nR
        error( 'Incompatible OS realizations and parameter array.' )
    end
    if ifOutTrg
        Out.nCT = size( Data.outTrg, 1 );
        if ~isfield( Out, 'Trg' ) || numel( Out.Trg ) ~= Out.nCT
            error( 'Incompatible OS target components and parameter array.' )
        end 
    end
end

%% ABBREVIATED SOURCE AND TARGET COMPONENT NAMES
componentNamesArg = {};
if isfield( In, 'sourceComponentName' )
    componentNamesArg = [ componentNamesArg ...
                          'sourceComponentName' In.sourceComponentName ];
end
if isfield( In, 'targetComponentName' )
    componentNamesArg = [ componentNamesArg ...
                         'targetComponentName' In.targetComponentName ];
end
if isfield( In, 'densityComponentName' )
    componentNamesArg = [ componentNamesArg ...
                         'densityComponentName' In.densityComponentName ];
end

%% ABBREVIATE IN-SAMPLE AND OUT-OF-SAMPLE REALIZATION NAMES
realizationNamesArg = {};
if isfield( In, 'sourceRealizationName' )
    realizationNamesArg = [ realizationNamesArg ...
                            'sourceRealizationName' In.sourceRealizationName ];
end
if isfield( In, 'targetRealizationName' )
    realizationNamesArg = [ realizationNamesArg ...
                            'targetRealizationName' In.targetRealizationName ];
end
if ifDen && isfield( In, 'densityRealizationName' )
    realizationNamesArg = [ realizationNamesArg ...
                           'densityRealizationName' In.densityRealizationName ];
end
if ifOse && isfield( Out, 'outRealizationName' )
    realizationNamesArg = [ realizationNamesArg ...
                            'outRealizationName' Out.outRealizationName ];
end
if ifOse && ifDen && isfield( Out, 'outDensityRealizationName' )
    realizationNamesArg = [ realizationNamesArg ...
                       'OutDensityRealizationName' Out.densityRealizationName ];
end
    

%% TIMESTAMPS
if isfield( In, 'tFormat' )
    timeFormatArg = { 'timeFormat', In.tFormat };
else
    timeFormatArg = {};
end
if isfield( In.Res( 1 ), 'tNum' )
    tNum = cell( 1, In.nR );
    for iR = 1 : In.nR
        tNum{ iR } = In.Res( iR ).tNum;
    end
    srcTimeArg = { 'sourceTime', tNum };
else
    srcTimeArg = {};
end
if ifOse && isfield( Out, 'tFormat' )
    outTimeFormatArg = { 'outTimeFormat', Out.tFormat };
else
    outTimeFormatArg = {};
end
if ifOse && isfield( Out.Res( 1 ), 'tNum' )
    tNumO = cell( 1, Out.nR );
    for iR = 1 : Out.nR
        tNumO{ iR } = Out.Res( iR ).tNum;
    end
    outTimeArg = { 'outTime', tNumO };
else
    outTimeArg = {};
end

%% DELAY-EMBEDDING ORIGINGS
nSETot = 0;
idxT1 = zeros( 1, In.nR );
for iR = In.nR : -1 : 1
    nSETot = nSETot + In.Res( iR ).nSE;
    idxT1( iR ) = In.Res( iR ).idxT1;
end
if ifOse
    idxT1O = zeros( 1, Out.nR );
    for iR = Out.nR : -1 : 1
        idxT1O( iR ) = Out.Res( iR ).idxT1;
    end
end

%% NEAREST NEIGHBORS
if In.nN == 0
   In.nN = nSETot;
end 
if In.nNS == 0
    In.nNS = nSETot;
end
if ifOse
    if Out.nN == 0
        Out.nN = nSETot;
    end
    if Out.nNO == 0
        Out.nNO = nSETot;
    end
end

%% DIMENSION ESTIMATES
if ifDen
    if In.nC > 1 && isscalar(In.denND)
        In.denND = repmat(In.denND, [In.nC 1]);
    end
    if ifOse
        if Out.nC > 1 && isscalar(Out.denND)
            Out.denND = repmat(Out.denND, [Out.nC 1]);
        end
    end
end

%% IN-SAMPLE AND OUT-OF-SAMPLE DATA PARTITIONS
% Loop over realizations for in-sample and out-of-sample data
% embPartition is a vector of nlsaPartitions for the delay-embedded data
% embPartitionQ is the query partition for the delay-embedded data
% embPartitionT is the test partition fot the delay-embedded data
% recPartition is a vector of nlsaPartitions for the reconstructed data
% outEmbPartition is a vector of nlsaPartitions for the OS delay-embedded data
% outRecPartition is a vector of nlsaPartitions for the OSE reconstructed data
for iR = In.nR : -1 : 1

    embPartition( iR ) = nlsaPartition( 'nSample', In.Res( iR ).nSE, ...
                                        'nBatch',  In.Res( iR ).nB  );
    recPartition( iR ) = nlsaPartition( 'nSample', In.Res( iR ).nSRec, ...
                                        'nBatch',  In.Res( iR ).nBRec );
end
if ifPartitionQ
    embPartitionQ = coarsenPartition( mergePartitions( embPartition ), In.nBQ );
    embeddingPartitionQArg = { 'embeddingPartitionQ', embPartitionQ, ...
                               'denEmbeddingPartitionQ', embPartitionQ };
else
    embeddingPartitionQArg = {};
end
if ifPartitionT
    embPartitionT = coarsenPartition( mergePartitions( embPartition ), In.nBT );
    embeddingPartitionTArg = { 'embeddingPartitionT', embPartitionT, ...
                               'denEmbeddingPartitionT', embPartitionT };
else
    embeddingPartitionTArg = {};
end
if ifOse
    for iR = Out.nR : -1 : 1

        outEmbPartition( iR ) = nlsaPartition( ...
                                    'nSample', Out.Res( iR ).nSE, ...
                                    'nBatch',  Out.Res( iR ).nB  );
        oseRecPartition( iR ) = nlsaPartition( ...
                                    'nSample', Out.Res( iR ).nSRec, ...
                                    'nBatch',  Out.Res( iR ).nBRec ); 
    end
end


%% DELAY-EMBEDDING TEMPLATES FOR IN-SAMPLE DATA
% Loop over source components to create embedding templates
for iC = In.nC : -1 : 1
    switch In.Src( iC ).embFormat
        case 'evector'
            if In.Src( iC ).fdOrder <= 0
                embComponent( iC, 1 ) = nlsaEmbeddedComponent_e( ...
                                    'idxE',    In.Src( iC ).idxE, ... 
                                    'nXB',     In.Src( iC ).nXB, ...
                                    'nXA',     In.Src( iC ).nXA );
            else
                embComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_e( ...
                                    'idxE',    In.Src( iC ).idxE, ... 
                                    'nXB',     In.Src( iC ).nXB, ...
                                    'nXA',     In.Src( iC ).nXA, ...
                                    'fdOrder', In.Src( iC ).fdOrder, ...
                                    'fdType',  In.Src( iC ).fdType );
            end
        case 'overlap'
            if In.Src( iC ).fdOrder <= 0
                embComponent( iC, 1 ) = nlsaEmbeddedComponent_o( ...
                                    'idxE',    In.Src( iC ).idxE, ...
                                    'nXB',     In.Src( iC ).nXB, ...
                                    'nXA',     In.Src( iC ).nXA );
            else
                embComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_o( ...
                                    'idxE',    In.Src( iC ).idxE, ...
                                    'nXB',     In.Src( iC ).nXB, ...
                                    'nXA',     In.Src( iC ).nXA, ...
                                    'fdOrder', In.Src( iC ).fdOrder, ...
                                    'fdType',  In.Src( iC ).fdType );
            end
    end
end

% Loop over target components to create embedding templates
for iC = In.nCT : -1 : 1
    switch In.Trg( iC ).embFormat
        case 'evector'
            if In.Trg( iC ).fdOrder <= 0
                trgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_e( ...
                                      'idxE',    In.Trg( iC ).idxE, ... 
                                      'nXB',     In.Trg( iC ).nXB, ...
                                      'nXA',     In.Trg( iC ).nXA );
            else
                trgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_e( ...
                                      'idxE',    In.Trg( iC ).idxE, ... 
                                      'nXB',     In.Trg( iC ).nXB, ...
                                      'nXA',     In.Trg( iC ).nXA, ...
                                      'fdOrder', In.Trg( iC ).fdOrder, ...
                                      'fdType',  In.Trg( iC ).fdType );
             end
        case 'overlap'
            if In.Trg( iC ).fdOrder <= 0 
                trgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_o( ...
                                       'idxE',    In.Trg( iC ).idxE, ...
                                       'nXB',     In.Trg( iC ).nXB, ...
                                       'nXA',     In.Trg( iC ).nXA );
            else
                trgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_o( ...
                                       'idxE',    In.Trg( iC ).idxE, ...
                                       'nXB',     In.Trg( iC ).nXB, ...
                                       'nXA',     In.Trg( iC ).nXA, ...
                                       'fdOrder', In.Trg( iC ).fdOrder, ...
                                       'fdType',  In.Trg( iC ).fdType );
            end
    end
end


%% DELAY-EMBEDDING TEMPLATES FOR OUT-OF-SAMPLE DATA
if ifOse
    % Loop over out-of-sample source components to create embedding templates
    for iC = Out.nC : -1 : 1
        switch Out.Src( iC ).embFormat
            case 'evector'
                if Out.Src( iC ).fdOrder <= 0
                    outEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_e( ...
                                            'idxE',    Out.Src( iC ).idxE, ... 
                                            'nXB',     Out.Src( iC ).nXB, ...
                                            'nXA',     Out.Src( iC ).nXA );
                else
                    outEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_e( ...
                                        'idxE',    Out.Src( iC ).idxE, ... 
                                        'nXB',     Out.Src( iC ).nXB, ...
                                        'nXA',     Out.Src( iC ).nXA, ...
                                        'fdOrder', Out.Src( iC ).fdOrder, ...
                                        'fdType',  Out.Src( iC ).fdType );
                end
            case 'overlap'
                if Out.Src( iC ).fdOrder <= 0
                    outEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_o( ...
                                            'idxE',    Out.Src( iC ).idxE, ...
                                            'nXB',     Out.Src( iC ).nXB, ...
                                            'nXA',     Out.Src( iC ).nXA );
                else

                    outEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_xi_o( ...
                                        'idxE',    Out.Src( iC ).idxE, ...
                                        'nXB',     Out.Src( iC ).nXB, ...
                                        'nXA',     Out.Src( iC ).nXA, ...
                                        'fdOrder', Out.Src( iC ).fdOrder, ...
                                        'fdType',  Out.Src( iC ).fdType );
                end
        end
    end
end

if ifOse && ifOutTrg    
    % Loop over out-of-sample target components to create embedding templates
    for iC = Out.nCT : -1 : 1
        switch Out.Trg( iC ).embFormat
            case 'evector'
                if Out.Trg( iC ).fdOrder <= 0
                    outTrgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_e( ...
                                      'idxE',    Out.Trg( iC ).idxE, ... 
                                      'nXB',     Out.Trg( iC ).nXB, ...
                                      'nXA',     Out.Trg( iC ).nXA );
                else
                    outTrgEmbComponent( iC, 1 ) ...
                                = nlsaEmbeddedComponent_xi_e( ...
                                      'idxE',    Out.Trg( iC ).idxE, ... 
                                      'nXB',     Out.Trg( iC ).nXB, ...
                                      'nXA',     Out.Trg( iC ).nXA, ...
                                      'fdOrder', Out.Trg( iC ).fdOrder, ...
                                      'fdType',  Out.Trg( iC ).fdType );
                 end
            case 'overlap'
                if Out.Trg( iC ).fdOrder <= 0
                    outTrgEmbComponent( iC, 1 ) = nlsaEmbeddedComponent_o( ...
                                       'idxE',    Out.Trg( iC ).idxE, ...
                                       'nXB',     Out.Trg( iC ).nXB, ...
                                       'nXA',     Out.Trg( iC ).nXA );
                else
                    outTrgEmbComponent( iC, 1 ) = ...
                                nlsaEmbeddedComponent_xi_o( ...
                                       'idxE',    Out.Trg( iC ).idxE, ...
                                       'nXB',     Out.Trg( iC ).nXB, ...
                                       'nXA',     Out.Trg( iC ).nXA, ...
                                       'fdOrder', Out.Trg( iC ).fdOrder, ...
                                       'fdType',  Out.Trg( iC ).fdType );
                end
        end
    end
    outTargetEmbeddingTemplateArg = { 'outTargetEmbeddingTemplate' ...
                                      outTrgEmbComponent  };
else
   outTargetEmbeddingTemplateArg = { }; 
end

%% PROJECTED COMPONENTS
for iC = In.nCT : -1 : 1
    if isa( trgEmbComponent( iC, 1 ), 'nlsaEmbeddedComponent_xi' )
        prjComponent( iC ) = nlsaProjectedComponent_xi( ...
                             'nBasisFunction', In.nPhiPrj );
    else
        prjComponent( iC ) = nlsaProjectedComponent( ...
                             'nBasisFunction', In.nPhiPrj );
    end
end

%% GLOBAL SETTINGS FOR PAIRWISE DISTANCES
% Select mode for pairwise distances based on embeddding format
if all( strcmp( { In.Src.embFormat }, 'overlap' ) ) ...
    && ~ifPartitionQ && ~ifPartitionT
    modeStr = 'implicit';
else
    modeStr = 'explicit';
end

% Number of parallel workers 
if ~isfield( In, 'nParE' ) % delay-embedding sums 
    In.nParE = 0; 
end
if ~isfield( In, 'nParNN' ) % nearest-neighbor search
    In.nParNN = 0;
end
if ifOse
    if ~isfield( Out, 'nParE' ) % delay-embedding sums 
        Out.nParE = 0; 
    end
    if ~isfield( Out, 'nParNN' ) % nearest-neighbor search
        Out.nParNN = 0;
    end
end


%% PAIRWISE DISTANCE FOR DENSITY ESTIMATION FOR IN-SAMPLE DATA
if ifDen
    switch In.denLDist
        case 'l2' % L^2 distance
            denLDist = nlsaLocalDistance_l2( 'mode', modeStr, ...
                                             'nPar', In.nParE );

        case 'at' % "autotuning" NLSA kernel
            denLDist = nlsaLocalDistance_at( 'mode', modeStr );

        case 'cone' % cone kernel
            denLDist = nlsaLocalDistance_cone( 'mode',      modeStr, ...
                                               'zeta',      In.denZeta, ...
                                               'tolerance', In.tol, ...
                                               'alpha',     In.denConeAlpha );
    end

    denDFunc = nlsaLocalDistanceFunction( 'localDistance', denLDist );

    denPDist = nlsaPairwiseDistance( 'nearestNeighbors', In.nN, ...
                                     'distanceFunction', denDFunc, ...
                                     'nPar', In.nParNN );

    denPDist = repmat( denPDist, [ In.nC 1 ] );
end

%% PAIRWISE DISTANCE FOR DENSITY ESTIMATION FOR OUT-OF-SAMPLE
if ifDen && ifOse
    switch Out.denLDist
        case 'l2' % L^2 distance
            denLDist = nlsaLocalDistance_l2( 'mode', modeStr, ...
                                             'nPar', Out.nParE );

        case 'at' % "autotuning" NLSA kernel
            denLDist = nlsaLocalDistance_at( 'mode', modeStr );

        case 'cone' % cone kernel
            denLDist = nlsaLocalDistance_cone( 'mode',      modeStr, ...
                                               'zeta',      Out.denZeta, ...
                                               'tolerance', Out.tol, ...
                                               'alpha',     Out.denConeAlpha );
    end

    denDFunc = nlsaLocalDistanceFunction( 'localDistance', denLDist );

    oseDenPDist = nlsaPairwiseDistance( 'nearestNeighbors', Out.nN, ...
                                        'distanceFunction', denDFunc, ...
                                        'nPar',             Out.nParNN );

    oseDenPDist = repmat( oseDenPDist, [ Out.nC 1 ] );
end

%% KERNEL DENSITY ESTIMATION FOR IN-SAMPLE DATA
if ifDen 
    for iC = In.nC : -1 : 1
        switch In.denType
            case 'fb' % fixed bandwidth
                den(iC) = nlsaKernelDensity_fb( ...
                           'dimension',              In.denND(iC), ...
                           'epsilon',                In.denEpsilon, ...
                           'bandwidthBase',          In.denEpsilonB, ...
                           'bandwidthExponentLimit', In.denEpsilonE, ...
                           'nBandwidth',             In.denNEpsilon );

            case 'vb' % variable bandwidth 
                den(iC) = nlsaKernelDensity_vb( ...
                           'dimension',              In.denND(iC), ...
                           'epsilon',                In.denEpsilon, ...
                           'kNN',                    In.denNN, ...
                           'bandwidthBase',          In.denEpsilonB, ...
                           'bandwidthExponentLimit', In.denEpsilonE, ...
                           'nBandwidth',             In.denNEpsilon );
        end
    end
    den = den'; % make den a column vector
    % den = repmat( den, [ In.nC 1 ] );
end

%% KERNEL DENSITY ESTIMATION FOR OUT-OF-SAMPLE DATA
if ifDen && ifOse
    for iC = Out.nC : -1 : 1
        switch Out.denType
            case 'fb' % fixed bandwidth
                oseDen(iC) = nlsaKernelDensity_ose_fb( ...
                               'dimension',            Out.denND(iC), ...
                               'epsilon',              Out.denEpsilon );

            case 'vb' % variable bandwidth 
                oseDen(iC) = nlsaKernelDensity_ose_vb( ...
                               'dimension',            Out.denND(iC), ...
                               'kNN',                  Out.denNN, ...
                               'epsilon',              Out.denEpsilon );
        end
    end
    oseDen = oseDen'; % make oseDen a column vector
    % oseDen = repmat( oseDen, [ Out.nC 1 ] );
end

%% PAIRWISE DISTANCES FOR IN-SAMPLE DATA
switch In.lDist
    case 'l2' % L^2 distance
        lDist = nlsaLocalDistance_l2( 'mode', modeStr, ...
                                      'nPar', In.nParE );

    case 'at' % "autotuning" NLSA kernel
        lDist = nlsaLocalDistance_at( 'mode', modeStr ); 

    case 'cone' % cone kernel
        lDist = nlsaLocalDistance_cone( 'mode', modeStr, ...
                                        'zeta', In.zeta, ...
                                        'tolerance', In.tol, ...
                                        'alpha', In.coneAlpha );
end
if ifDen
    lScl = nlsaLocalScaling_pwr( 'pwr', 1 ./ In.denND );
    dFunc = nlsaLocalDistanceFunction_scl( 'localDistance', lDist, ...
                                           'localScaling', lScl );
else
    dFunc = nlsaLocalDistanceFunction( 'localDistance', lDist );
end
pDist = nlsaPairwiseDistance( 'distanceFunction', dFunc, ...
                              'nearestNeighbors', In.nN, ...
                              'nPar',             In.nParNN );

%% PAIRWISE DISTANCES FOR OUT-OF-SAMPLE DATA
if ifOse
    switch Out.lDist
        case 'l2' % L^2 distance
            lDist = nlsaLocalDistance_l2( 'mode', modeStr, ...
                                          'nPar', Out.nParE );

        case 'at' % "autotuning" NLSA kernel
            lDist = nlsaLocalDistance_at( 'mode', modeStr ); 

        case 'cone' % cone kernel
            lDist = nlsaLocalDistance_cone( 'mode', modeStr, ... 
                                            'zeta', In.zeta, ...
                                            'tolerance', In.tol, ...
                                            'alpha', In.coneAlpha );
    end

    if ifDen
        lScl = nlsaLocalScaling_pwr( 'pwr', 1 ./ Out.denND );
        oseDFunc = nlsaLocalDistanceFunction_scl( 'localDistance', lDist, ...
                                                  'localScaling', lScl );
    else
        oseDFunc = nlsaLocalDistanceFunction( 'localDistance', lDist );
    end
    osePDist = nlsaPairwiseDistance( 'distanceFunction', oseDFunc, ...
                                     'nearestNeighbors', Out.nN, ...
                                     'nPar',             Out.nParNN );
end

%% SYMMETRIZED PAIRWISE DISTANCES
sDist = nlsaSymmetricDistance_gl( 'nearestNeighbors', In.nNS );

%% DIFFUSION OPERATOR FOR IN-SAMPLE DATA
% Check if Markov normalization parameter has been specified; if not set to 
% default.
if ~isfield( In, 'beta' )
    In.beta = 1;
end

switch In.diffOpType
    % global storage format, fixed bandwidth
    case 'gl'
        diffOp = nlsaDiffusionOperator_gl( 'alpha',          In.alpha, ...
                                           'beta',           In.beta, ...
                                           'epsilon',        In.epsilon, ...
                                           'nEigenfunction', In.nPhi );

    % global storage format, multiple bandwidth (automatic bandwidth selection)
    case 'gl_mb' 
        diffOp = nlsaDiffusionOperator_gl_mb( ...
                     'alpha',                  In.alpha, ...
                     'beta',                   In.beta, ...
                     'epsilon',                In.epsilon, ...
                     'nEigenfunction',         In.nPhi, ...
                     'bandwidthBase',          In.epsilonB, ...
                     'bandwidthExponentLimit', In.epsilonE, ...
                     'nBandwidth',             In.nEpsilon );

    % global storage format, multiple bandwidth (automatic bandwidth selection and SVD)
    case 'gl_mb_svd' 
        diffOp = nlsaDiffusionOperator_gl_mb_svd( ...
                     'alpha',                  In.alpha, ...
                     'beta',                   In.beta, ...
                     'epsilon',                In.epsilon, ...
                     'nEigenfunction',         In.nPhi, ...
                     'bandwidthBase',          In.epsilonB, ...
                     'bandwidthExponentLimit', In.epsilonE, ...
                     'nBandwidth',             In.nEpsilon );

    case 'gl_mb_bs'
        diffOp = nlsaDiffusionOperator_gl_mb_bs( ...
                     'alpha',                  In.alpha, ...
                     'beta',                   In.beta, ...
                     'epsilon',                In.epsilon, ...
                     'nEigenfunction',         In.nPhi, ...
                     'bandwidthBase',          In.epsilonB, ...
                     'bandwidthExponentLimit', In.epsilonE, ...
                     'nBandwidth',             In.nEpsilon );

    case 'gl_mb_bs_pf'
        diffOp = nlsaDiffusionOperator_gl_mb_bs_pf( ...
                     'alpha',                  In.alpha, ...
                     'beta',                   In.beta, ...
                     'epsilon',                In.epsilon, ...
                     'nEigenfunction',         In.nPhi, ...
                     'bandwidthBase',          In.epsilonB, ...
                     'bandwidthExponentLimit', In.epsilonE, ...
                     'nBandwidth',             In.nEpsilon );

end

%% DIFFUSION OPERATOR FOR OUT-OF-SAMPLE DATA
if ifOse
    
    % Check if Markov normalization parameter has been specified; if not set to 
    % default.
    if ~isfield( Out, 'beta' )
        Out.beta = In.beta;
    end

    %TODO: Add gl_mb_bs_pf case. 
    switch Out.diffOpType
        case 'gl_mb_svd'
            oseDiffOp = nlsaDiffusionOperator_ose_svd( ...
                                       'alpha',          Out.alpha, ...
                                       'beta',           Out.beta, ...
                                       'epsilon',        Out.epsilon, ...
                                       'epsilonT',       In.epsilon, ...
                                       'nNeighbors',     Out.nNO, ...
                                       'nNeighborsT',    In.nNS, ...
                                       'nEigenfunction', Out.nPhi );
        case 'gl_mb_bs'
            oseDiffOp = nlsaDiffusionOperator_ose_bs( ...
                                       'alpha',          Out.alpha, ...
                                       'beta',           Out.beta, ...
                                       'epsilon',        Out.epsilon, ...
                                       'epsilonT',       In.epsilon, ...
                                       'nNeighbors',     Out.nNO, ...
                                       'nNeighborsT',    In.nNS, ...
                                       'nEigenfunction', Out.nPhi );

        otherwise
            oseDiffOp = nlsaDiffusionOperator_ose( ...
                                       'alpha',          Out.alpha, ...
                                       'beta',           Out.beta, ...
                                       'epsilon',        Out.epsilon, ...
                                       'epsilonT',       In.epsilon, ...
                                       'nNeighbors',     Out.nNO, ...
                                       'nNeighborsT',    In.nNS, ...
                                       'nEigenfunction', Out.nPhi );
    end
end
 
%% KOOPMAN OPERATOR 
if ifKoopman
    switch In.koopmanOpType

        % Diffusion regularization
        case 'diff'
            koopmanOp = nlsaKoopmanOperator_diff( ...
                        'samplingInterval',        In.koopmanDt, ...
                        'fdOrder',                 In.koopmanFDOrder, ...
                        'fdType',                  In.koopmanFDType, ...  
                        'antisym',                 In.koopmanAntisym, ...
                        'regularizationParameter', In.koopmanEpsilon, ...
                        'regularizationType',      In.koopmanRegType, ...
                        'basisFunctionIdx',        In.idxPhiKoopman, ...
                        'nEigenfunction',          In.nPhiKoopman );

        % RKHS compactification
        case 'rkhs'
            koopmanOp = nlsaKoopmanOperator_rkhs( ...
                        'samplingInterval',        In.koopmanDt, ...
                        'fdOrder',                 In.koopmanFDOrder, ...
                        'fdType',                  In.koopmanFDType, ...  
                        'antisym',                 In.koopmanAntisym, ...
                        'regularizationParameter', In.koopmanEpsilon, ...
                        'regularizationType',      In.koopmanRegType, ...
                        'basisFunctionIdx',        In.idxPhiKoopman, ...
                        'nEigenfunction',          In.nPhiKoopman );

        % "Raw" Koopman operator without regularization
        case 'raw'
            koopmanOp = nlsaKoopmanOperator( ...
                        'samplingInterval',        In.koopmanDt, ...
                        'fdOrder',                 In.koopmanFDOrder, ...
                        'fdType',                  In.koopmanFDType, ...  
                        'antisym',                 In.koopmanAntisym, ...
                        'basisFunctionIdx',        In.idxPhiKoopman, ...
                        'nEigenfunction',          In.nPhiKoopman );
    end
    koopmanOperatorTemplateArg = { 'koopmanOperatorTemplate' koopmanOp };

else
    koopmanOperatorTemplateArg = { };
end
                        
%% KOOPMAN PROJECTED COMPONENTS
if ifKoopman
    for iC = In.nCT : -1 : 1
        if isa( trgEmbComponent( iC, 1 ), 'nlsaEmbeddedComponent_xi' )
            koopmanPrjComponent( iC ) = nlsaProjectedComponent_xi( ...
                                 'nBasisFunction', In.nKoopmanPrj );
        else
            koopmanPrjComponent( iC ) = nlsaProjectedComponent( ...
                                 'nBasisFunction', In.nKoopmanPrj );
        end
    end
    koopmanOperatorTemplateArg = [ koopmanOperatorTemplateArg ...
                                   'koopmanProjectionTemplate' ...
                                   { koopmanPrjComponent } ];
end




%% LINEAR MAP FOR SVD OF TARGET DATA
linMap = nlsaLinearMap_gl( 'basisFunctionIdx', In.idxPhiSVD );


%% RECONSTRUCTED TARGET COMPONENTS -- IN-SAMPLE DATA
% Reconstructed data from diffusion eigenfnunctions
if ~isfield( In, 'idxPhiRec' )
    In.idxPhiRec = 1;
end
if ~iscell( In.idxPhiRec )
    idxPhiRec = { In.idxPhiRec };
else
    idxPhiRec = In.idxPhiRec;
end
for iRec = numel( idxPhiRec ) : -1 : 1
    recComponent( iRec ) = ...
        nlsaComponent_rec_phi( 'basisFunctionIdx', idxPhiRec{ iRec } );
end

% Reconstructed data from SVD 
if ~isfield( In, 'idxVTRec' )
    In.idxVTRec = 1;
end
svdRecComponent = nlsaComponent_rec_phi( 'basisFunctionIdx', In.idxVTRec );


% Reconstructed data from Koopman
if ifKoopman
    if ~isfield( In, 'idxKoopmanRec' )
        In.idxKoopmanRec = 1;
    end
    if ~iscell( In.idxKoopmanRec )
        idxKoopmanRec = { In.idxKoopmanRec };
    else
        idxKoopmanRec = In.idxKoopmanRec; 
    end
    for iRec = numel( idxKoopmanRec ) : -1 : 1
        koopmanRecComponent( iRec ) = nlsaComponent_rec_phi( ...
            'basisFunctionIdx',  idxKoopmanRec{ iRec } );
    end
    koopmanOperatorTemplateArg = [ koopmanOperatorTemplateArg ...
                                   'koopmanReconstructionTemplate' ... 
                                   { koopmanRecComponent } ];
end

%% RECONSTRUCTED TARGET COMPONENTS -- OUT-OF-SAMPLE DATA
if ifOse
    % Nystrom extension
    oseEmbTemplate = nlsaEmbeddedComponent_ose_n( ...
        'eigenfunctionIdx', Out.idxPhiRecOSE );
    oseRecComponent = nlsaComponent_rec();
end

%% BUILD NLSA MODEL    

if ifOse
    if ifDen
        % Variable-bandwidth kernel and out-of-sample extension
        model = nlsaModel_den_ose( ...
                   'path',                             nlsaPath, ...
                   'sourceComponent',                  srcComponent, ...
                   'targetComponent',                  trgComponent, ...
                   componentNamesArg{ : },             ...
                   realizationNamesArg{ : },           ...
                   timeFormatArg{ : },                 ...
                   srcTimeArg{ : },                    ...
                   'embeddingOrigin',                  idxT1, ...
                   'embeddingTemplate',                embComponent, ...
                   'targetEmbeddingTemplate',          trgEmbComponent, ...
                   'embeddingPartition',               embPartition, ...
                   embeddingPartitionQArg{ : },        ...
                   embeddingPartitionTArg{ : },        ...
                   'denPairwiseDistanceTemplate',      denPDist, ...
                   'kernelDensityTemplate',            den, ...
                   'pairwiseDistanceTemplate',         pDist, ...
                   'symmetricDistanceTemplate',        sDist, ...
                   'diffusionOperatorTemplate',        diffOp, ...
                   'projectionTemplate',               prjComponent, ...
                   'reconstructionPartition',          recPartition, ...
                   'reconstructionTemplate',           recComponent, ...
                   koopmanOperatorTemplateArg{ : },    ...
                   'linearMapTemplate',                linMap, ...
                   'svdReconstructionTemplate',        svdRecComponent, ...
                   'outComponent',                     outComponent, ...
                   outTargetComponentArg{ : },         ...
                   outTimeFormatArg{ : },              ...
                   outTimeArg{ : },                    ...
                   'outEmbeddingOrigin',               idxT1O, ...
                   'outEmbeddingTemplate',             outEmbComponent, ...
                   outTargetEmbeddingTemplateArg{ : }, ...
                   'outEmbeddingPartition',            outEmbPartition, ... 
                   'osePairwiseDistanceTemplate',      osePDist, ...
                   'oseDenPairwiseDistanceTemplate',   oseDenPDist, ...
                   'oseKernelDensityTemplate',         oseDen, ...
                   'oseDiffusionOperatorTemplate',     oseDiffOp, ...
                   'oseEmbeddingTemplate',             oseEmbTemplate, ...
                   'oseReconstructionPartition',       oseRecPartition );

    else
        % Out-of-sample extension
        model = nlsaModel_ose( ...
                   'path',                             nlsaPath, ...
                   'sourceComponent',                  srcComponent, ...
                   'targetComponent',                  trgComponent, ...
                   componentNamesArg{ : },             ...
                   realizationNamesArg{ : },           ...
                   timeFormatArg{ : },                 ...
                   srcTimeArg{ : },                    ...
                   'embeddingOrigin',                  idxT1, ...
                   'embeddingTemplate',                embComponent, ...
                   'targetEmbeddingTemplate',          trgEmbComponent, ...
                   'embeddingPartition',               embPartition, ...
                   embeddingPartitionQArg{ : },        ...
                   embeddingPartitionTArg{ : },        ...
                   'pairwiseDistanceTemplate',         pDist, ...
                   'symmetricDistanceTemplate',        sDist, ...
                   'diffusionOperatorTemplate',        diffOp, ...
                   koopmanOperatorTemplateArg{ : },    ...
                   'projectionTemplate',               prjComponent, ...
                   'reconstructionTemplate',           recComponent, ...
                   'reconstructionPartition',          recPartition, ...
                   'linearMapTemplate',                linMap, ...
                   'svdReconstructionTemplate',        svdRecComponent, ...
                   'outComponent',                     outComponent, ...
                   outTargetComponentArg{ : },         ...
                   outTimeFormatArg{ : },              ...
                   outTimeArg{ : },                    ...
                   'outEmbeddingOrigin',               idxT1O, ...
                   'outEmbeddingTemplate',             outEmbComponent, ...
                   outTargetEmbeddingTemplateArg{ : }, ...
                   'outEmbeddingPartition',            outEmbPartition, ... 
                   'osePairwiseDistanceTemplate',      osePDist, ...
                   'oseDiffusionOperatorTemplate',     oseDiffOp, ...
                   'oseEmbeddingTemplate',             oseEmbTemplate, ...
                   'oseReconstructionPartition',       oseRecPartition );
    end
else 

    if ifDen                
        % Variable-bandwidth kernel 
        model = nlsaModel_den( ...
                   'path',                            nlsaPath, ...
                   'sourceComponent',                 srcComponent, ...
                   'targetComponent',                 trgComponent, ...
                   componentNamesArg{ : }, ...
                   realizationNamesArg{ : },           ...
                   timeFormatArg{ : },                 ...
                   srcTimeArg{ : },                    ...
                   'embeddingOrigin',                 idxT1, ...
                   'embeddingTemplate',               embComponent, ...
                   'targetEmbeddingTemplate',         trgEmbComponent, ...
                   'embeddingPartition',              embPartition, ...
                   embeddingPartitionQArg{ : },        ...
                   embeddingPartitionTArg{ : },        ...
                   'denPairwiseDistanceTemplate',     denPDist, ...
                   'kernelDensityTemplate',           den, ...
                   'pairwiseDistanceTemplate',        pDist, ...
                   'symmetricDistanceTemplate',       sDist, ...
                   'diffusionOperatorTemplate',       diffOp, ...
                   koopmanOperatorTemplateArg{ : },   ...
                   'projectionTemplate',              prjComponent, ...
                   'reconstructionTemplate',          recComponent, ...
                   'reconstructionPartition',         recPartition, ...
                   'linearMapTemplate',               linMap, ...
                   'svdReconstructionTemplate',       svdRecComponent );

    else
        %  Basic NLSA model
        model = nlsaModel( ...
                   'path',                            nlsaPath, ...
                   'sourceComponent',                 srcComponent, ...
                   'targetComponent',                 trgComponent, ...
                   componentNamesArg{ : }, ...
                   realizationNamesArg{ : },          ...
                   timeFormatArg{ : },                ...
                   srcTimeArg{ : },                   ...
                   'embeddingOrigin',                 idxT1, ...
                   'embeddingTemplate',               embComponent, ...
                   'targetEmbeddingTemplate',         trgEmbComponent, ...
                   'embeddingPartition',              embPartition, ...
                   embeddingPartitionQArg{ : },        ...
                   embeddingPartitionTArg{ : },        ...
                   'pairwiseDistanceTemplate',        pDist, ...
                   'symmetricDistanceTemplate',       sDist, ...
                   'diffusionOperatorTemplate',       diffOp, ...
                   koopmanOperatorTemplateArg{ : },   ...
                   'projectionTemplate',              prjComponent, ...
                   'reconstructionTemplate',          recComponent, ...
                   'reconstructionPartition',         recPartition, ...
                   'linearMapTemplate',               linMap, ...
                   'svdReconstructionTemplate',       svdRecComponent );
   end
end

